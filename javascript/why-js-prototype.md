# [자바스크립트는 왜 프로토타입을 선택했을까](https://medium.com/@limsungmook/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%99%9C-%ED%94%84%EB%A1%9C%ED%86%A0%ED%83%80%EC%9E%85%EC%9D%84-%EC%84%A0%ED%83%9D%ED%96%88%EC%9D%84%EA%B9%8C-997f985adb42)

(궁금점) 자바스크립트는 왜 다른 언어처럼 클래스가 아니라 프로토타입을 사용할까요? 호이스팅과 this는 왜 그렇게 처리할까요? 문맥을 강조하는 프로토타입이라는 철학적 근거에서 태어났기 때문입니다.

> 앞으로 전개될 글 내용을 미리 요약하면, 프로토타입 기반 OOP는 class 기반의 OOP 와 완전히 상반되는 방식입니다. 객체를 바라보는 개념 자체가 완전히 다릅니다. 특히 문맥(context)을 매우 강조하는 철학적 근거에서 태어난 녀석이라 렉시컬 스코프에 의한 호이스팅과 실행 문맥에 의한 복잡한 this가 필연적으로 발생할 수밖에 없었습니다.

(비교) 프로토타입을 이해하려면 그 대척점에 있는 클래스의 기원을 알아야 합니다. "구체적으로 존재하는 사물이 있다면 반드시 그것의 본질이 존재한다."는 게 클래스의 기원입니다.

> 의자를 예로 들어보면 우리가 앉아있는 의자는 여러 가지 형태가 존재합니다. 원목 의자, 바퀴 달린 의자, 하이 체어 등등. 이러한 수많은 의자가 실제로 존재한다면 반드시 그 본질적이고 추상적인 '의자'라는 것이 존재한다는 것이지요.
>
> 이러한 사고방식이 프로그래밍 언어에도 자연스럽게 녹아들어 생긴 언어가 "클래스 기반 객체지향 프로그래밍 언어"입니다. 대표적으로 Java, C# 이 있습니다.

```java
class Chair {
...
}

Chair myChair = new Chair();
```

> 위 코드에서 레퍼런스 타입이라 불리는 Chair 클래스는 이데아에 존재하는 추상적인 개념입니다. 즉, 코드상으로만 존재하지 실제 메모리상에는 존재하지 않습니다. (디테일하게 들어가면 PermGen 영역에 있겠지만 여기서는 Heap 메모리만 실존하는 공간으로 보겠습니다)
>
> 그럼 현실세계에 존재하게 하려면 어떻게 해야 할까요? 바로 new 키워드를 사용하면 됩니다. new Chair() 를 하는 순간 추상적으로만 존재하던 의자가 메모리라는 현실세계에 구체적으로 존재(인스턴스화)하게 됩니다.
>
> 이러한 클래스 방식의 OOP 언어는 플라톤류(Platonic) 서양철학의 자연스러운 흐름입니다.

(정의) 클래스 개념에 따르면 속성이 동일하다면 같은 범주입니다. 즉, 프로그래밍 관점에서 보면 프로퍼티가 유사한 객체가 있다면 일반화 과정을 통해 클래스로 추상화할 수 있습니다.

> 플라톤의 이데아 이론은 그의 제자 아리스토텔레스에 의해서 '분류(classification)'란 개념으로 정립됩니다. class 라는 키워드가 어디서 나온 지 알 수 있겠죠? 아리스토텔레스는 아래와 같이 분류를 정리했습니다.
>
> - 개체의 속성이 동일한 경우 개체 그룹이 같은 범주에 속한다. 범주는 정의와 구별의 합이다
>
> 이는 전통적인 클래스 기반 객체 지향 프로그래밍의 아이디어-일반화(generalization)와 정확히 일치합니다. 여기서 속성은 클래스의 프로퍼티가 되겠죠. 프로퍼티가 유사한 객체가 있다면 일반화 과정을 통해 클래스로 추상화됩니다.
>
> 실제로 아리스토텔레스는 이러한 기준으로 현실 세계의 많은 것들을 분류했고, 최초로 동물을 분류한 사람이 되었습니다. 속성에 따른 분류로 인해 돌고래는 어류가 아닌 포유류가 되었죠.

(비교) 그러나 프로토타입 이론은 분류(Classification)이론을 정면으로 반박합니다. 공통 속성을 정의하기 어려운 개념이 있다고 반례를 듭니다.

> 19세기 매우 유명한 철학자 비트겐슈타인은 아리스토텔레스의 분류 개념을 정면으로 반박합니다
>
> > 공유 속성의 관점에서 정의하기 어려운 개념이 있다(사실상 올바른 분류란 없다) — 비트겐슈타인
>
> 이 얘기를 하면서 근거로 들고 온 것은 바로 게임입니다. 게임은 일반적으로 승리와 패배가 명확합니다. 즉 '승리'와 '패배'라는 속성이 있다고 볼 수 있죠. 하지만 비트겐슈타인은 이에 대한 반론으로 '승리', '패배'가 없는 `ring around a rosy`를 들고옵니다. (한국에서 자란 저는 이 게임이 뭔지 잘 모르겠습니다; 승자가 없는 게임이라고 합니다)
>
> 이처럼 게임에는 공유 속성이 없습니다.
>
> - 승리 / 패배? ring around a rosy 게임엔 없잖아
> - 숙련도 여부? 행운(주사위) 위주 게임은 없잖아
> - 플레이어 존재여부? 플레이어가 전혀 필요하지 않는 게임도 있잖아
>
> 특히 게임 외에도 예술작품의 경우 공통 속성을 정의할 수 없습니다. 즉, 좀 더 철학적으로 본다면 '게임', '예술' 등의 단어는 결코 속성으로 규정할 수 없지요.
>
> > 세계에 미리 내재되어서 대상과 언어를 완전히 규정하는 어떤 언어란 존재하지 않는다 — 비트겐슈타인

(사례) 실제로 프로그래밍 관점에서 최적의 클래스를 설계하는 것은 매우 어렵습니다. 또한 공통 속성으로 분류하는 것이 확장성을 고려할 때 좋은 방식이 아닌 경우도 있습니다.

> 저는 Java로 개발하는 동안 이러한 본질적인 한계를 자주 느꼈습니다. 최적의 클래스 설계를 찾는 것이 너무 어려웠습니다. 속성(property)으로 분류하는 것은 확장성을 고려하면 좋은 방식이 아니었습니다. 정답이라 생각했던 설계도 개발이 진행되면서 뒤엎는 경우가 많았습니다.

(대안) 프로토타입 이론은 클래스 이론을 반박하면서, 단어의 '진정한 본래의 의미'란 존재하지 않고 '상황과 맥락에 의해서 결정된다'고 대안을 제시합니다. '컨텍스트(context)'가 중요하다는 것이죠. 또한 인간은 실제로 대상을 분류할 때 클래스 관점에서 이야기하는 속성이 아니라 가족 유사성을 통해 분류한다고 말합니다. 공통 속성이 없어도 어떤 특징으로 분류할 수 있다는 거죠.

> 이러한 분류(Classification)에 대해 강하게 비판한 비트겐슈타인, 그렇다면 그의 대안은 무엇이었을까요? 비트겐슈타인은 다음의 유명한 말을 남깁니다.
>
> > 표현은 삶의 흐름 속에서만 의미를 갖는다 — 비트겐슈타인
>
> 마음에 울림이 있는 문구입니다. 이 내용을 좀 더 살펴보겠습니다.

> 의미사용이론(the use theory of meaning)
>
> 비트겐슈타인 일생의 후기에 내놓은 이론입니다. 사용(use)에 의해 의미(meaning)가 결정된다는 이론입니다. 단어의 쓰임새가 곧 의미가 됩니다. 즉, 단어의 '진정한 본래의 의미'란 존재하지 않고 '상황과 맥락에 의해서 결정된다'라고 주장하고 있습니다. 그러니 단어의 의미를 백날 분석해봤자 소용이 없다는 것입니다.
> 비트겐슈타인은 '벽돌'을 예로 들었습니다. 누군가 벽돌! 이라 외쳤을 때 상황마다 그 의미는 달라집니다.
>
> - (벽돌이 필요할 때) : 벽돌을 달라
> - (벽돌로 보수해야 할 때) : 벽돌을 채우라
> - (벽돌이 떨어질 때) : 벽돌을 피해라
>
> 위 내용이 어렵다면 맥락(Context)이 중요하다는 것만 기억하시면 됩니다. 이 컨텍스트로 프로토타입 기반 언어의 실행 컨텍스트를 설명할 수 있습니다. (자세한 건 뒤에)

> 가족 유사성(Family Resemblance)
>
> 비트겐슈타인은 위에서 설명한 의미사용이론과 또 하나의 이론을 주장합니다. 바로 가족 유사성입니다.
>
> 비트겐슈타인은 인간이 현실에서 실제로 대상을 분류할 때 속성(전통적인 분류에서의 기준)이 아닌 가족 유사성을 통해 분류하게 된다고 얘기합니다.
> 위 그림처럼 가족이 있을 때 이 가족이 모두 공유하는 공통 속성은 없습니다. 갈색 머리, 안경, 수염, 큰 코가 가족의 전형적인 특징이라고 하더라도 모든 가족 구성원에게 적용되는 공통된 특성(속성)은 없을 수 있습니다. 그런데도 우리는 이 그림을 보고 전형적인 특징을 통해 '가족'으로 분류합니다. 이런 분류 방식을 '가족 유사성' 에 의한 분류라고 합니다.
>
> 이 이론은 프로토타입 이론의 근거가 됩니다.

(구체) 비트겐슈타인의 의미사용이론, 가족 유사성은 로쉬에 의해 프로토타입 이론으로 정리됩니다. 요약하면, 인간은 사물을 분류할 때 자연스럽게 가장 유사성이 높은 것 순서대로 등급을 매긴다는 의미입니다. 이때 가장 높은 등급을 가진 것이 바로 원형(Prototype)이라고 주장합니다. 즉, 객체는 '정의'로부터 분류되는 것이 아니라 가장 좋은 보기(prototype)으로부터 범주화된다고 합니다.

> 새'를 예로 들어볼까요? '참새'는 새의 범주를 대표할 만한 가장 전형적인 녀석입니다. 이 녀석을 '원형(prototype)'으로 간주하겠습니다.
>
> 타조'는 전통적인 분류에선 같은 새가 되지만 프로토타입 이론에서는 '원형'에서 가장 멀리 떨어진, 즉 '비전형적인' 녀석이 됩니다. 범주의 가장 끄트머리에 있는 녀석이 되는 거죠.
>
> 즉, 객체는 '정의'로부터 분류되는 것이 아니라 가장 좋은 보기(prototype, exemplar)로부터 범주화된다고 합니다.

(장점) 프로토타입의 분류 체계는 경제적입니다. 새로운 대상을 분류해야 할 때 공통 속성을 뽑아내서 최적의 클래스를 만들어낼 필요 없습니다. 새로운 대상의 몇 가지 특징만 원형(프로토타입)과 비교하기만 하면 됩니다. 특징이 다를수록 원형에서 멀리 떨어진 범주가 되는 거죠. 또한 중요한 한 가지는 같은 단어라 할지라도 누가 어떤 상황에서 접했느냐에 따라 의미가 달라진다는 것입니다.

> 예를 들면 아이가 생각하는 새의 범주에서 '참새'는 명확하게 새에 속하지만 '펭귄' 은 해당 범주에 속하지 못할 수도 있습니다. 아이가 생각할 땐 펭귄이 매우 비전형적이기 때문이죠. 하지만 조류학자가 생각할 때 '참새'와 '펭귄'은 명확하게 유사한 새의 범주에 속할 수 있습니다. 같은 단어여도 어떤 상황(누가, 어디서…)에서 접했나에 따라 범주는 크게 달라집니다.
>
> 와! 정말 어렵네요. 그래도 여기까지 모두 이해하셨다면 앞으로는 꽃길만 걸을 수 있습니다. 이해가 안 되셨다면 다음 두 가지만 기억하셔도 될 것 같습니다.
>
> - 현실에 존재하는 것 중 가장 좋은 본보기를 원형(prototype)으로 선택한다.
> - 문맥(컨텍스트)에 따라 '범주', 즉 '의미'가 달라진다.

(적용) 프로토타입 기반 OOP 언어의 특징은 다음과 같습니다.

- 프로토타입 언어에서는 '분류'를 우선하지 않는다. 생성된 객체 위주로 유사성을 정의한다.
- 어휘, 쓰임새는 맥락(context)에 의해 평가된다.
  - 실행 컨텍스트, 스코프 체인이 여기서 파생되었습니다
  - 클로져, this, 호이스팅 등등. 이 모든 헬(?) 이 프로토타입의 '맥락'을 표현하기 위한 것입니다.

(예제)

to be conitunued...
