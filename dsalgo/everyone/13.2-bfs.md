# 너비 우선 탐색

## 시작

너비 우선 탐색(BFS) 알고리즘은 다음으로 처리할 정점을 추적하기 위해 큐를 이용한다. 그리고 최초의 큐는 시작점(ex. "Alice")만 포함한다.

```ruby
["Alice"]
```

1. 큐에 시작점인 앨리스를 추가한다. `[Alcie]`
2. 앨리스를 큐로부터 제거하고 엘리스를 `현재 정점`으로 만든다.
3. 앨리스에게 방문했다는 의미로 `방문 했음` 체크 부호를 표시한다.
4. 방문하지 않은 (앨리스의) 인접 정점인 밥을 방문한다.
   1. `방문 했음` 체크 부호를 표시한다.
   2. 밥을 큐에 추가한다. `[Bob]` (큐에 밥이 있다는 것은 아직 밥은 `현재 정점`이 아니란 의미이다)
5. 앨리스의 인접 정점 중 방문하지 않은 정점인 캔디를 방문한다. (4 반복)
   1. `방문 했음` 체크 부호를 표시한다.
   2. 캔디를 큐에 추가한다. `[Bob, Candy]`
6. 앨리스의 인접 정점 중 방문하지 않은 정점인 데릭을 방문한다. (4 반복)
   1. `방문 했음` 체크 부호를 표시한다.
   2. 데릭을 큐에 추가한다. `[Bob, Candy, Derek]`
7. 앨리스의 인접 정점을 모두 방문했으므로 큐에서 정점을 삭제(dequeue)해서 그 정점을 `현재 정점`으로 만든다.
8. 현재 정점의 인접 정점이 없고 큐도 비어 있으면 끝!

## 패턴

1. 네트워크가 연결된 자료구조가 있다.
2. 시작 정점으로부터 탐색을 시작한다.
   1. 비어 있는 큐에 시작 정점을 추가한다.
   2. 큐에서 시작 정점을 제거하고 시작 정점을 현재 정점으로 지정한다.
3. 현재 정점을 "방문 했음"으로 표시한다.
4. 현재 정점이 정해지면 모든 인접 정점을 방문한다. (loop)
   1. 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다.
5. 현재 정점의 인접 정점을 모두 방문했으므로 큐에서 가장 앞에 있는 정점을 현재 정점으로 만들고 3을 반복한다.

예시:

1. 네트워크가 연결된 자료구조가 있다.
2. 시작 정점 `A`로부터 탐색을 시작한다.
   1. 비어 있는 큐에 시작 정점을 추가한다. `[A]`
   2. 큐에서 시작 정점을 제거하고 시작 정점 `[A]`을 현재 정점으로 지정한다.
3. 현재 정점 `A`를 "방문 했음"으로 표시한다.
4. 현재 정점이 정해지면 모든 인접 정점을 방문한다. (loop)
   1. 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다.
      1. `B`가 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다. `[B]`
      2. `C`가 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다. `[B, C]`
      3. `D`가 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다. `[B, C, D]`
      4. `E`가 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다. `[B, C, D, E]`
5. 현재 정점의 인접 정점을 모두 방문했으므로 큐에서 가장 앞에 있는 정점을 현재 정점으로 만들고 3을 반복한다. (loop)
   1. `B`를 큐에서 제거하고 `B`를 현재 정점으로 지정한다.
   2. 현재 정점 `B`를 "방문 했음"으로 표시한다.
   3. 모든 인접 정점을 방문한다 (loop)
      1. `F`가 방문한 적이 없는 인접 정점이면 방문했다고 표시("방문 했음" 큐?)하고, 큐에 추가한다. `[C, D, E, F]`
   4. 현재 정점의 인접 정점을 모두 방문했으므로 큐에서 가장 앞에 있는 정점 `C`를 현재 정점으로 만들고 3을 반복한다. (loop)

## 코드

```js
const graph = {
  A: ["B", "C"],
  B: ["A", "D"],
  C: ["A", "G", "H", "I"],
  D: ["B", "E", "F"],
  E: ["D"],
  F: ["D"],
  G: ["C"],
  H: ["C"],
  I: ["C", "J"],
  J: ["I"],
};

const bfs = (graph, startNode) => {
  const queue = [startNode]; // 탐색할 정점 목록 큐
  const visited = {}; // 방문한 정점을 표시하는 해시 테이블
  visited[startNode] = true;
  const history = []; // 탐색한 정점을 순서대로 저장하는 배열

  while (queue.length) {
    const currentNode = queue.shift();
    history.push(currentNode);

    // 현재 정점의 인접 정점을 "모두 방문"(너비 탐색)한다.
    graph[currentNode].forEach((neighbor) => {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        queue.push(neighbor); // 방문하지 않은 인접 노드는 앞으로 탐색해야 할 노드이므로 추가한다.
      }
    });
  }

  return history;
};

console.log(bfs(graph, "A"));
// ["A", "B", "C", "D", "G", "H", "I", "E", "F", "J"]
```

사용한 자료구조:

- `queue[]`: 탐색할 정점 목록 큐
- `visited{}`: 방문한 정점을 표시하는 해시 테이블
- `history[]`: 탐색한 정점을 순서대로 저장하는 배열

여기서 visited 해시 테이블을 배열로 만들어서 history 배열을 없앨 수도 있다:

```js
const bfs2 = (graph, startNode) => {
  const queue = [startNode]; // 탐색할 정점 목록 큐
  const visited = [startNode]; // 방문한 정점을 차례대로 저장하는 배열

  while (queue.length) {
    const currentNode = queue.shift();

    const neighbors = graph[currentNode];
    neighbors.forEach((neighbor) => {
      if (!visited.includes(neighbor)) {
        visited.push(neighbor);
        queue.push(neighbor);
      }
    });
  }

  return visited;
};
console.log(bfs2(graph, "A"));
// ["A", "B", "C", "D", "G", "H", "I", "E", "F", "J"]
```
