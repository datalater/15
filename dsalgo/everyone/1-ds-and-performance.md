# 1장 자료구조가 중요한 까닭

## 연산이 얼마나 빠른가

연산이 얼마나 빠른가를 측정할 때는 순수한 시간 관점이 아니라 **얼마나 많은 단계**가 필요한지를 논의해야 한다.

## 연산의 종류

- 읽기:
  - 자료 구조에서 특정 위치를 찾아보는 것
  - ex. 배열에서 인덱스 3의 값을 읽는 것
- 검색:
  - 자료 구조에서 특정 값을 찾는 것
  - ex. 배열에 "banana"가 있는지 확인하는 것, 있다면 어떤 인덱스에 있는지 알아보는 것
- 삽입
- 삭제

## 컴퓨터가 배열의 특정 인덱스에 있는 값을 빠르게 읽을 수 있는 이유

> **🚀TLDR**:
>
> 배열에는 메모리 시작 주소가 있고 컴퓨터는 메모리 주소에 한 번에 갈 수 있기 때문이다.

다음과 같은 점들이 복합적으로 작용한다.

1. 컴퓨터는 모든 메모리 주소에 한 번에 갈 수 있다. 왜냐하면 메모리 주소는 위치가 정확하기 때문이다.
2. 각 배열에 저장된 내용은 메모리의 시작 주소다. 따라서 컴퓨터는 배열의 시작 주소에 바로 접근할 수 있다.
3. 배열의 인덱스는 0부터 시작한다.

예를 들어, 컴퓨터에게 인덱스 3에 있는 값을 읽으라고 명령하면:

1. 배열의 인덱스는 0부터 시작하며 인덱스 0의 메모리 주소는 (예를 들어) `1010`이다.
2. 인덱스 3은 인덱스 0부터 정확히 세 슬롯 뒤에 있다.
3. 따라서 인덱스 3을 찾으려면 `1010 + 3`인 `1013` 메모리 주소로 간다.

## 컴퓨터가 검색하는 방식

> **🚀TLDR**:
>
> 눈이 없으니까 차례대로 확인하는 과정을 반복한다.

쇼핑 목록에 대한 배열이 있을 때 우리는 눈으로 "hat"을 바로 찾은 후 머릿속으로 빠르게 인덱스가 3임을 계산한다. 하지만 컴퓨터는 눈이 없으므로 차례대로 배열을 찾을 수밖에 없다.

배열에서 값을 찾을 때 컴퓨터는 인덱스 0부터 시작해서 값을 확인한 후 찾는 값이 아니면 다음 인덱스로 이동한다 발견할 때까지 이 과정을 반복한다.

이와 같이 한 번에 한 셀씩 확인하는 방법을 **선형 검색**이라 부른다.

## 집합 자료구조를 삽입할 때 걸리는 연산 단계

> **🚀TLDR**:
>
> 집합은 중복되지 않아야 하므로 모든 삽입 전에 검색을 필수적으로 거쳐야 한다.

집합은 자료가 중복되지 않아야 한다. 그래서 삽입하기 전에 먼저 삽입하려는 대상이 현재 자료에 없는지 "검색"부터 해야 한다. 따라서 검색에 필요한 N단계가 추가로 걸린다. 결국 배열의 삽입의 최악의 경우의 수인 N+1(가장 앞에 삽입하는 경우 N개의 요소를 하나씩 뒤로 옮기는 N단계 + 맨앞에 추가하는 1단계 = N+1)에다가 검색 N단계를 합쳐 (최악의 시나리오일 때) 2N+1이 걸린다.

## 자료 구조 성능 측정의 핵심은

> **🚀TLDR**:
>
> 연산을 마치려면 몇 단계가 걸리느냐가 성능 측정의 핵심이다.

연산에 필요한 단계 수를 구하는 게 자료 구조 성능 측정의 핵심이다.
